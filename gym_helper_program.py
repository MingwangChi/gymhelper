# -*- coding: utf-8 -*-
"""Gym helper program.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K0fNrI_lfzxpZ_PWIFOTCBtMND-y0sve

# 1st step: install ipywidgets
"""

!pip install ipywidgets

"""# 2nd step: run the code"""

import time, json, os
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output

# === Global Data ===
user_profile = {}
session_history = []
streak_data = {"last_date": None, "current_streak": 0, "longest_streak": 0}
goals = {"workouts": 5, "volume": 10000, "streak_goal": 7}
pinned_plan = {}
saved_plans = {}

# === Exercise DB ===
exercise_db = {
    "squat": {"primary": "legs", "description": "Full lower body movement."},
    "leg press": {"primary": "legs", "description": "Leg strength machine exercise."},
    "lunges": {"primary": "legs", "description": "Great for unilateral leg training."},
    "bench press": {"primary": "chest", "description": "Chest compound press."},
    "push-up": {"primary": "chest", "description": "Bodyweight chest press."},
    "chest fly": {"primary": "chest", "description": "Isolated chest movement."},
    "deadlift": {"primary": "back", "description": "Total posterior chain."},
    "barbell row": {"primary": "back", "description": "Back compound pull."},
    "lat pulldown": {"primary": "back", "description": "Vertical pulling back exercise."},
    "bicep curl": {"primary": "biceps", "description": "Classic biceps movement."},
    "hammer curl": {"primary": "biceps", "description": "Neutral grip bicep curl."},
    "preacher curl": {"primary": "biceps", "description": "Isolated curl on bench."},
    "plank": {"primary": "core", "description": "Static core hold."},
    "crunch": {"primary": "core", "description": "Abdominal flexion exercise."},
    "leg raise": {"primary": "core", "description": "Lower ab isolation exercise."}
}

# === Health Calculators ===
def calculate_bmi(weight_kg, height_cm):
    height_m = height_cm / 100
    return round(weight_kg / (height_m ** 2), 2)

def calculate_calories(weight, height, age, gender, activity_level):
    bmr = (10 * weight) + (6.25 * height) - (5 * age)
    bmr += 5 if gender.lower() == 'male' else -161
    factor = {"low": 1.2, "medium": 1.55, "high": 1.9}
    return round(bmr * factor.get(activity_level, 1.2), 2)

def calculate_protein(weight_kg, goal='maintenance'):
    factor = {"cut": 2.0, "bulk": 2.2, "maintenance": 1.6}
    return round(weight_kg * factor.get(goal, 1.6), 2)

class GymHelperWidget:
    def __init__(self):
        self.user_profile = user_profile
        self.session_history = session_history
        self.streak_data = streak_data
        self.goals = goals
        self.pinned_plan = pinned_plan
        self.saved_plans = saved_plans

         # --- Timer variables ---
        self.timer_running = False
        self.timer_thread = None  # To hold the threading.Thread instance
        self.countdown_total_seconds = 0
        self.countdown_remaining_seconds = 0
        self.timer_label = widgets.Label("00:00:00") # This widget displays the countdown
        self.timer_output = widgets.Output() # For messages like "Timer started/stopped"

        self.exercise_db = exercise_db
        self.day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        self.gym_schedule = {day: "" for day in self.day_names}

        self.init_profile_tab()
        self.init_schedule_tab()
        self.init_exercises_tab()
        self.init_session_tab()
        self.init_goals_tab()
        self.init_misc()
        self.init_pr_tab()

        self.tabs = widgets.Tab(children=[
            self.profile_tab,
            self.schedule_tab,
            self.exercises_tab,
            self.session_tab,
            self.goals_tab,
            self.misc_tab,
            self.pr_tab
        ])
        tab_names = ["Profile", "Schedule", "Exercises", "Session", "Goals", "Misc", "PR"]
        for i, name in enumerate(tab_names):
            self.tabs.set_title(i, name)

        display(self.tabs)

        self.update_profile_display()
        self.update_schedule_graph()
        self.on_muscle_change({'new': 'All'})
        self.update_streak_display()
        self.show_today_plan_reminder()

     def init_timer_tab(self):
        """Initializes the widgets for the timer tab."""
        self.timer_input = widgets.IntText(
            description="Set Timer (minutes):",
            value=1,  # Default to 1 minute
            min=0
        )
        self.start_timer_btn = widgets.Button(description="Start Timer")
        self.stop_timer_btn = widgets.Button(description="Stop Timer")

        # Attach event handlers to buttons
        self.start_timer_btn.on_click(self.on_start_timer)
        self.stop_timer_btn.on_click(self.on_stop_timer)

        # Assemble the timer tab UI
        self.timer_tab = widgets.VBox([
            widgets.Label("Workout Timer"),
            widgets.HBox([self.timer_input, self.start_timer_btn, self.stop_timer_btn]),
            self.timer_label,  # This label will display the countdown
            self.timer_output  # For messages from the timer logic
        ])

    def on_start_timer(self, _):
        """Handles the 'Start Timer' button click."""
        with self.timer_output:
            clear_output() # Clear previous timer messages
            if self.timer_running:
                print("Timer is already running.")
                return

            minutes = self.timer_input.value
            if minutes < 0:
                print("Please enter a non-negative number of minutes.")
                return

            self.countdown_total_seconds = minutes * 60
            self.countdown_remaining_seconds = self.countdown_total_seconds
            self.timer_running = True

            # Format and display initial time immediately
            mins, secs = divmod(self.countdown_remaining_seconds, 60)
            hours, mins = divmod(mins, 60)
            self.timer_label.value = f"{hours:02d}:{mins:02d}:{secs:02d}"

            print("Timer started!")
            # Create and start the timer in a separate thread
            self.timer_thread = threading.Thread(target=self._run_timer)
            self.timer_thread.start() # <<< THIS IS THE CRUCIAL FIX: Start the thread!

    def on_stop_timer(self, _):
        """Handles the 'Stop Timer' button click."""
        with self.timer_output:
            if self.timer_running:
                self.timer_running = False  # Set flag to stop the _run_timer loop
                self.countdown_remaining_seconds = 0
                self.timer_label.value = "00:00:00" # Reset label immediately
                print("Timer stopped.")
            else:
                print("Timer is not running.")

    def _run_timer(self):
        """The main countdown logic, run in a separate thread."""
        # Loop as long as the timer is supposed to be running AND there's time left
        while self.timer_running and self.countdown_remaining_seconds > 0:
            # Calculate hours, minutes, and seconds from remaining seconds
            mins, secs = divmod(self.countdown_remaining_seconds, 60)
            hours, mins = divmod(mins, 60)

            # Update the label with the formatted time
            # Using f-strings with :02d ensures two-digit display (e.g., 05 instead of 5)
            self.timer_label.value = f"{hours:02d}:{mins:02d}:{secs:02d}"

            time.sleep(1)  # Pause for 1 second
            self.countdown_remaining_seconds -= 1 # Decrement the counter

        # After the loop finishes (either naturally or stopped manually)
        if self.countdown_remaining_seconds <= 0 and self.timer_running:
            # If the timer ran to completion (not stopped manually)
            self.timer_running = False # Ensure the flag is false
            self.timer_label.value = "00:00:00" # Set label to final state
            with self.timer_output:
                clear_output() # Clear previous messages before printing "Time's up!"
                print("Time's up!")
        # If it was stopped manually, on_stop_timer already handled the label and message.

    def init_schedule_tab(self):
        self.schedule_widgets = {day: widgets.Text(
            description=day,
            value=self.gym_schedule.get(day, ""),
            placeholder="Type your plan..."
        ) for day in self.day_names}
        self.save_schedule_btn = widgets.Button(description="Save Schedule")
        self.schedule_graph_out = widgets.Output()

        self.save_schedule_btn.on_click(self.on_save_schedule)

        self.schedule_tab = widgets.VBox(
            [widgets.Label("Custom Weekly Workout Schedule")] +
            list(self.schedule_widgets.values()) +
            [self.save_schedule_btn, self.schedule_graph_out]
        )

    def on_save_schedule(self, _):
        for day in self.day_names:
            self.gym_schedule[day] = self.schedule_widgets[day].value
        self.update_schedule_graph()
        with self.schedule_graph_out:
            clear_output()
            print("Schedule saved!")

    def update_schedule_graph(self):
        with self.schedule_graph_out:
            clear_output()
            labels = list(self.gym_schedule.keys())
            values = [1 if self.gym_schedule[d].strip() else 0 for d in labels]
            fig, ax = plt.subplots(figsize=(6, 2))
            ax.bar(labels, values, color='purple')
            ax.set_ylim(0, 1.5)
            ax.set_yticks([])
            ax.set_title("Weekly Plan Presence")
            plt.show()

    def show_today_plan_reminder(self):
        today = datetime.now().strftime("%a")
        plan = self.gym_schedule.get(today, "Rest")
        display(widgets.HTML(f"<b>📅 Today is {today}. Your plan: {plan}</b>"))

    def init_pr_tab(self):
        self.pr_records = {}
        self.pr_input = widgets.Text(description="Exercise")
        self.pr_value = widgets.FloatText(description="Max Weight")
        self.pr_btn = widgets.Button(description="Save PR")
        self.pr_output = widgets.Output()

        self.pr_btn.on_click(self.save_pr)

        self.pr_tab = widgets.VBox([
            widgets.Label("Personal Records (PRs)"),
            self.pr_input,
            self.pr_value,
            self.pr_btn,
            self.pr_output
        ])

    def save_pr(self, _):
        ex = self.pr_input.value
        wt = self.pr_value.value
        if ex:
            self.pr_records[ex] = wt
            with self.pr_output:
                clear_output()
                for k, v in self.pr_records.items():
                    print(f"{k}: {v} kg")

"""### second version"""

import time, json, os
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output
import threading
from google.colab import drive

# === Google Drive Setup ===
drive.mount('/content/drive')
save_path = '/content/drive/MyDrive/GymHelperData'
os.makedirs(save_path, exist_ok=True)

# === Global Data ===
user_profile = {}
session_history = []
streak_data = {"last_date": None, "current_streak": 0, "longest_streak": 0}
goals = {
    "workouts": 5, "volume": 10000, "streak_goal": 7,
    "weight_goal_kg": 0.0, "muscle_mass_goal_kg": 0.0, "body_fat_goal_percent": 0.0 # New goals
}
pinned_plan = {}
saved_plans = {}
gym_schedule = {day: "Rest" for day in ["Monday", "Tueday", "Weday", "Thursday", "Friday", "Saturday", "Sunday"]} # Initialize with day names
daily_workout_plans = {} # New: Store customized daily workout plans

# === Save/Load Functions ===
def save_all_data():
    with open(f"{save_path}/user_profile.json", "w") as f: json.dump(user_profile, f)
    with open(f"{save_path}/session_history.json", "w") as f: json.dump(session_history, f)
    with open(f"{save_path}/streak_data.json", "w") as f: json.dump(streak_data, f)
    with open(f"{save_path}/goals.json", "w") as f: json.dump(goals, f)
    with open(f"{save_path}/pinned_plan.json", "w") as f: json.dump(pinned_plan, f)
    with open(f"{save_path}/saved_plans.json", "w") as f: json.dump(saved_plans, f)
    with open(f"{save_path}/gym_schedule.json", "w") as f: json.dump(gym_schedule, f) # Save gym_schedule
    with open(f"{save_path}/daily_workout_plans.json", "w") as f: json.dump(daily_workout_plans, f) # Save daily_workout_plans


def load_all_data():
    global user_profile, session_history, streak_data, goals, pinned_plan, saved_plans, gym_schedule, daily_workout_plans
    try:
        with open(f"{save_path}/user_profile.json", "r") as f: user_profile = json.load(f)
        with open(f"{save_path}/session_history.json", "r") as f: session_history = json.load(f)
        with open(f"{save_path}/streak_data.json", "r") as f: streak_data = json.load(f)
        with open(f"{save_path}/goals.json", "r") as f:
            loaded_goals = json.load(f)
            goals.update(loaded_goals) # Update, don't overwrite, to preserve new keys
        with open(f"{save_path}/pinned_plan.json", "r") as f: pinned_plan = json.load(f)
        with open(f"{save_path}/saved_plans.json", "r") as f: saved_plans = json.load(f)
        with open(f"{save_path}/gym_schedule.json", "r") as f: gym_schedule = json.load(f) # Load gym_schedule
        with open(f"{save_path}/daily_workout_plans.json", "r") as f: daily_workout_plans = json.load(f) # Load daily_workout_plans
    except FileNotFoundError:
        print("ℹ️ No previous data found, starting fresh.")
    except json.JSONDecodeError:
        print("⚠️ Error decoding JSON, starting fresh.")
        # Reset global data if JSON is corrupted
        user_profile.clear()
        session_history.clear()
        streak_data.update({"last_date": None, "current_streak": 0, "longest_streak": 0})
        goals.update({"workouts": 5, "volume": 10000, "streak_goal": 7, "weight_goal_kg": 0.0, "muscle_mass_goal_kg": 0.0, "body_fat_goal_percent": 0.0}) # Reset new goals too
        pinned_plan.clear()
        saved_plans.clear()
        gym_schedule.update({day: "Rest" for day in ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]})
        daily_workout_plans.clear()


load_all_data()

# === Exercise DB ===
exercise_db = {
   "squat": {
        "primary": "legs",
        "description": "Full lower body movement, builds strength in quads, hamstrings, and glutes. ⚠️Warning: Avoid letting your knees cave inward or heels lift off the ground. Keep your back neutral and don't round your spine",
    },
    "leg press": {"primary": "legs", "description": "Leg strength machine exercise, targets quads, hamstrings, and glutes with less lower back strain. ⚠️Warning: Don’t lock your knees at the top. Keep your lower back flat against the pad to prevent spinal strain."},
    "lunges": {"primary": "legs", "description": "Great for unilateral leg training, improves balance and targets quads, hamstrings, and glutes. ⚠️Warning: Don’t let your front knee extend past your toes. Maintain balance and upright posture to protect knees and hips."},
    "deadlift (conventional)": {"primary": "legs", "description": "Total posterior chain exercise, works hamstrings, glutes, and lower back. Excellent for overall strength. ⚠️Warning: Keep your back straight and engage your core. Don’t jerk the bar or round your spine to avoid injury."},
    "romanian deadlift": {"primary": "legs", "description": "Focuses on hamstrings and glutes, with less emphasis on the lower back than conventional deadlifts. ⚠️Warning: Avoid excessive rounding of your back. Keep a slight bend in your knees and hinge from the hips."},
    "calf raise": {"primary": "legs", "description": "Isolates the calf muscles (gastrocnemius and soleus). ⚠️Warning: Avoid bouncing at the top or bottom of the movement. Perform slow, controlled reps to prevent Achilles strain."},
    "leg extension": {"primary": "legs", "description": "Machine exercise that isolates the quadriceps. ⚠️Warning: Don’t lock out your knees at the top. Use moderate weight to reduce joint stress."},
    "leg curl": {"primary": "legs", "description": "Machine exercise that isolates the hamstrings. ⚠️Warning: Don’t lift your hips off the pad. Avoid jerky motion to reduce hamstring strain."},
    "glute bridge": {"primary": "legs", "description": "Targets glutes and hamstrings, good for hip extension. ⚠️Warning: Don’t overarch your lower back. Engage your core and focus on glute contraction."},
    "bulgarian split squat": {"primary": "legs", "description": "Unilateral exercise, great for leg strength, balance, and glute development. ⚠️Warning: Don’t let your front knee collapse inward. Keep your torso upright and move with control to avoid knee strain."},


    "bench press": {"primary": "chest", "description": "Chest compound press, foundational for upper body pushing strength. ⚠️Warning: Don’t bounce the bar off your chest or flare your elbows excessively. Maintain a stable shoulder position."},
    "push-up": {"primary": "chest", "description": "Bodyweight chest press, also engages shoulders and triceps. ⚠️Warning: Don’t let your hips sag or flare. Keep a straight line from shoulders to heels."},
    "chest fly": {"primary": "chest", "description": "Isolated chest movement, focuses on pec major contraction. ⚠️Warning: Don’t overstretch your arms at the bottom. Use a controlled range to protect shoulder joints."},
    "incline dumbbell press": {"primary": "chest", "description": "Targets the upper chest, good for overall chest development. ⚠️Warning: Don’t arch your back too much. Keep wrists straight and control the weights throughout."},
    "dip (chest version)": {"primary": "chest", "description": "Bodyweight exercise for lower chest and triceps. ⚠️Warning: Avoid going too deep or letting your shoulders roll forward. This can cause impingement."},
    "cable crossover": {"primary": "chest", "description": "Versatile cable exercise for targeting different parts of the chest. ⚠️Warning: Don’t jerk the cables. Move smoothly to avoid shoulder injuries."},
    "dumbbell pullover": {"primary": "chest", "description": "Targets the chest and also works the lats and serratus anterior. ⚠️Warning: Avoid excessive overhead movement. Keep your core tight and avoid shoulder hyperextension."},
    "decline dumbbell press": {"primary": "chest", "description": "Emphasizes the lower part of the pectoralis major. ⚠️Warning: Secure your feet and avoid arching your lower back excessively during the press."},
    "pec deck fly": {"primary": "chest", "description": "Machine-based isolation for the chest, good for squeezing at the end. ⚠️Warning: Don’t bring the handles too far back. That can overextend the shoulders."},


    "deadlift": {"primary": "back", "description": "Total posterior chain, excellent for overall strength and back thickness. ⚠️Warning: Keep your spine neutral. Don’t round your back or use momentum to lift heavy weights."},
    "barbell row": {"primary": "back", "description": "Back compound pull, builds thickness in the mid-back. ⚠️Warning: Keep your back flat and avoid jerking the bar. Engage your core and avoid rounding."},
    "lat pulldown": {"primary": "back", "description": "Vertical pulling back exercise, targets the lats for width. ⚠️Warning: Don’t pull the bar behind your neck. Keep it in front of your chest to protect shoulders."},
    "pull-up": {"primary": "back", "description": "Bodyweight vertical pull, great for lat development and overall upper body strength. ⚠️Warning: Avoid swinging or kipping if not intentional. Control each rep and contract your scapula to avoid shoulder strain."},
    "t-bar row": {"primary": "back", "description": "Machine-based row for back thickness, targets lats and rhomboids. ⚠️Warning: Keep a flat back and avoid excessive weight that compromises form."},
    "face pull": {"primary": "back", "description": "Excellent for rear deltoids and upper back, improves posture. ⚠️Warning: Use light weight and keep control to avoid straining shoulder joints."},
    "hyperextension": {"primary": "back", "description": "Targets the lower back, glutes, and hamstrings. ⚠️Warning: Don’t overextend your spine at the top. Focus on controlled movement and glute activation."},
    "dumbbell row": {"primary": "back", "description": "Unilateral back exercise, great for targeting each side and improving core stability. ⚠️Warning: Keep your back neutral and avoid twisting your torso during the row."},
    "seated cable row": {"primary": "back", "description": "Machine-based horizontal pull, effective for mid-back thickness. ⚠️Warning: Don’t lean too far forward or backward. Keep your spine upright and stable."},
    "reverse fly (machine)": {"primary": "back", "description": "Targets the rear deltoids and upper back, especially effective on a machine. ⚠️Warning: Avoid using too much weight. Focus on form to avoid shoulder strain."},


    "bicep curl": {"primary": "biceps", "description": "Classic biceps movement for peak development. ⚠️Warning: Don’t swing the weights. Keep elbows tucked and use a full, controlled range."},
    "hammer curl": {"primary": "biceps", "description": "Neutral grip bicep curl, also targets brachialis and brachioradialis for forearm thickness. ⚠️Warning: Avoid using momentum. Keep your wrists in a neutral position to prevent strain."},
    "preacher curl": {"primary": "biceps", "description": "Isolated curl on bench, minimizes momentum for stricter form. ⚠️Warning: Don’t hyperextend your elbows at the bottom. Keep movement slow and controlled."},
    "concentration curl": {"primary": "biceps", "description": "Highly isolated bicep exercise, focuses on the peak contraction. ⚠️Warning: Avoid twisting your body for momentum. Focus on the bicep contraction."},
    "reverse curl": {"primary": "biceps", "description": "Targets the brachialis and brachioradialis, great for forearm strength. ⚠️Warning: Use moderate weight to avoid wrist strain. Keep your grip firm and controlled."},
    "chin-up": {"primary": "biceps", "description": "Bodyweight exercise heavily engaging biceps and lats. ⚠️Warning: Don’t swing or kip. Engage your core and avoid pulling with just the arms."},
    "incline dumbbell curl": {"primary": "biceps", "description": "Increases stretch on the biceps at the bottom of the movement. ⚠️Warning: Don’t let your shoulders roll forward. Keep a slow tempo and isolate the biceps."},
    "cable curl": {"primary": "biceps", "description": "Provides constant tension throughout the range of motion. ⚠️Warning: Don’t jerk the cable. Maintain constant tension and stable posture."},


    "overhead press": {"primary": "shoulders", "description": "Compound exercise for overall shoulder development. ⚠️Warning: Avoid arching your back. Press in a straight line and engage your core."},
    "dumbbell lateral raise": {"primary": "shoulders", "description": "Isolates the side deltoids for shoulder width. ⚠️Warning: Don’t lift above shoulder height or swing the weights."},
    "front raise": {"primary": "shoulders", "description": "Targets the front deltoids. ⚠️Warning: Avoid using heavy weights and swinging your body. Focus on front deltoid control."},
    "arnold press": {"primary": "shoulders", "description": "A rotational dumbbell press hitting all three heads of the deltoid. ⚠️Warning: Use proper rotation and don’t rush the movement to avoid rotator cuff injury."},
    "rear delt fly": {"primary": "shoulders", "description": "Targets the rear deltoids, often neglected, important for shoulder health. ⚠️Warning: Avoid shrugging your shoulders. Use light weight and control the rear delts."},
    "barbell shrug": {"primary": "shoulders", "description": "Targets the trapezius muscles (traps) for upper back and neck thickness. ⚠️Warning: Don’t roll your shoulders. Just lift them straight up and down."},
    "upright row": {"primary": "shoulders", "description": "Works shoulders and traps, can be done with barbell or dumbbells. ⚠️Warning: Don’t lift too high; stop at upper chest to avoid impingement."},


    "triceps pushdown": {"primary": "triceps", "description": "Isolation exercise for the triceps, good for shape and definition. ⚠️Warning: Keep elbows stationary. Don’t swing your body or flare out."},
    "overhead dumbbell extension": {"primary": "triceps", "description": "Targets the long head of the triceps. ⚠️Warning: Avoid arching your back. Keep elbows tight to your head."},
    "skullcrusher": {"primary": "triceps", "description": "Effective for triceps mass, also known as lying triceps extension. ⚠️Warning: Don’t drop the weight too fast. Maintain control to protect your elbows."},
    "close-grip bench press": {"primary": "triceps", "description": "Compound exercise heavily engaging triceps and chest. ⚠️Warning: Keep your wrists straight and elbows tucked in to reduce shoulder strain."},
    "kickback (dumbbell)": {"primary": "triceps", "description": "Isolation exercise focusing on the contraction of the triceps. ⚠️Warning: Avoid swinging your arms. Keep your upper arm stationary and control the weight."},
    "dips (triceps version)": {"primary": "triceps", "description": "Bodyweight compound exercise for triceps and chest. ⚠️Warning: Don’t go too deep. Avoid shoulder stress by using a controlled depth."},


    "plank": {"primary": "core", "description": "Static core hold, excellent for overall core stability. ⚠️Warning: Don’t let your hips sag or rise. Keep your core and glutes tight."},
    "crunch": {"primary": "core", "description": "Abdominal flexion exercise, targets rectus abdominis. ⚠️Warning: Avoid pulling on your neck. Use your core, not your arms, to lift."},
    "leg raise": {"primary": "core", "description": "Lower ab isolation exercise, also works hip flexors. ⚠️Warning: Don’t arch your lower back. Press your back into the floor throughout."},
    "russian twist": {"primary": "core", "description": "Targets the obliques for rotational strength. ⚠️Warning: Keep your spine neutral and avoid rapid twisting, especially with weight."},
    "side plank": {"primary": "core", "description": "Targets the obliques and improves lateral core stability. ⚠️Warning: Don’t let your hips drop. Keep your body aligned and avoid collapsing."},
    "ab roll-out": {"primary": "core", "description": "Advanced core exercise for full abdominal engagement. ⚠️Warning: Don’t let your lower back sag. Engage your core fully during rollout and return."},
    "bicycle crunch": {"primary": "core", "description": "Targets both rectus abdominis and obliques with a twisting motion. ⚠️Warning: Avoid jerking your neck forward. Focus on slow, controlled twisting."},
    "toes to bar": {"primary": "core", "description": "Advanced hanging exercise for full abdominal and hip flexor engagement. ⚠️Warning: Don’t swing excessively. Use controlled hip flexion and core strength."}
}

# === Recommended Workout Splits ===
# Define workout splits with their weekly schedules and recommended exercises.
# The exercise lists are simplified for demonstration. In a real app, these could be more extensive.
recommended_splits = {
    "Push-Pull-Legs (3-Day)": {
        "schedule": {
            "Mon": "Push",
            "Tue": "Pull",
            "Wed": "Legs",
            "Thu": "Rest",
            "Fri": "Rest",
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Push": ["bench press", "incline dumbbell press", "overhead press", "dumbbell lateral raise", "triceps pushdown", "overhead dumbbell extension"],
            "Pull": ["deadlift", "barbell row", "lat pulldown", "pull-up", "bicep curl", "hammer curl"],
            "Legs": ["squat", "leg press", "romanian deadlift", "leg extension", "leg curl", "calf raise"]
        }
    },
    "Push-Pull-Legs (6-Day)": {
        "schedule": {
            "Mon": "Push",
            "Tue": "Pull",
            "Wed": "Legs",
            "Thu": "Push",
            "Fri": "Pull",
            "Sat": "Legs",
            "Sun": "Rest"
        },
        "plans": {
            "Push": ["bench press", "incline dumbbell press", "overhead press", "dumbbell lateral raise", "triceps pushdown", "overhead dumbbell extension"],
            "Pull": ["barbell row", "lat pulldown", "seated cable row", "face pull", "bicep curl", "hammer curl"], # Removed deadlift for 6-day to reduce fatigue
            "Legs": ["squat", "leg press", "romanian deadlift", "leg extension", "leg curl", "glute bridge"]
        }
    },
    "Bro Split": {
        "schedule": {
            "Mon": "Chest",
            "Tue": "Back",
            "Wed": "Legs",
            "Thu": "Shoulders",
            "Fri": "Arms", # Biceps & Triceps
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Chest": ["bench press", "incline dumbbell press", "chest fly", "cable crossover"],
            "Back": ["lat pulldown", "seated cable row", "t-bar row", "hyperextension"],
            "Legs": ["squat", "leg press", "lunges", "leg extension", "leg curl"],
            "Shoulders": ["overhead press", "dumbbell lateral raise", "front raise", "barbell shrug"],
            "Arms": ["bicep curl", "hammer curl", "triceps pushdown", "skullcrusher"]
        }
    },
    "Full Body (3-Day)": {
        "schedule": {
            "Mon": "Full Body",
            "Tue": "Rest",
            "Wed": "Full Body",
            "Thu": "Rest",
            "Fri": "Full Body",
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Full Body": ["squat", "bench press", "barbell row", "overhead press", "leg extension", "bicep curl", "triceps pushdown", "plank"]
        }
    },
    "Upper/Lower (4-Day)": {
        "schedule": {
            "Mon": "Upper",
            "Tue": "Lower",
            "Wed": "Rest",
            "Thu": "Upper",
            "Fri": "Lower",
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Upper": ["bench press", "barbell row", "overhead press", "lat pulldown", "bicep curl", "triceps pushdown"],
            "Lower": ["squat", "romanian deadlift", "leg press", "leg extension", "leg curl", "calf raise"]
        }
    },
    "Arnold Split": { # Chest/Back, Shoulders/Arms, Legs
        "schedule": {
            "Mon": "Chest & Back",
            "Tue": "Shoulders & Arms",
            "Wed": "Legs & Abs",
            "Thu": "Rest",
            "Fri": "Chest & Back",
            "Sat": "Shoulders & Arms",
            "Sun": "Legs & Abs"
        },
        "plans": {
            "Chest & Back": ["bench press", "incline dumbbell press", "pull-up", "barbell row", "dumbbell pullover"],
            "Shoulders & Arms": ["overhead press", "dumbbell lateral raise", "bicep curl", "hammer curl", "triceps pushdown", "skullcrusher"],
            "Legs & Abs": ["squat", "leg press", "lunges", "leg extension", "leg curl", "calf raise", "crunch", "leg raise"]
        }
    },
    "5x5 StrongLifts/Madcow Style": { # Focus on compound lifts, progressive overload. Simplified.
        "schedule": {
            "Mon": "Workout A",
            "Tue": "Rest",
            "Wed": "Workout B",
            "Thu": "Rest",
            "Fri": "Workout A",
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Workout A": ["squat", "bench press", "barbell row"],
            "Workout B": ["squat", "overhead press", "deadlift"]
        }
    },
    "Body Part Split (5-Day)": {
        "schedule": {
            "Mon": "Chest",
            "Tue": "Back",
            "Wed": "Shoulders",
            "Thu": "Legs",
            "Fri": "Arms & Abs",
            "Sat": "Rest",
            "Sun": "Rest"
        },
        "plans": {
            "Chest": ["bench press", "incline dumbbell press", "pec deck fly", "cable crossover"],
            "Back": ["deadlift", "lat pulldown", "barbell row", "seated cable row"],
            "Shoulders": ["overhead press", "dumbbell lateral raise", "front raise", "rear delt fly"],
            "Legs": ["squat", "leg press", "romanian deadlift", "leg extension", "leg curl"],
            "Arms & Abs": ["bicep curl", "hammer curl", "triceps pushdown", "skullcrusher", "plank", "russian twist"]
        }
    }
}

# Collect all possible workout types/plan names from recommended splits for schedule dropdowns
all_possible_workout_types = set(["Rest", "Workout"])
for split_data in recommended_splits.values():
    all_possible_workout_types.update(split_data["schedule"].values())
    all_possible_workout_types.update(split_data["plans"].keys()) # Add plan names too for selection

# === Health Calculators ===
def calculate_bmi(weight_kg, height_cm):
    height_m = height_cm / 100
    if height_m == 0: return 0.0 # Avoid division by zero
    return round(weight_kg / (height_m ** 2), 2)

def calculate_calories(weight, height, age, gender, activity_level_key, goal):
    bmr = (10 * weight) + (6.25 * height) - (5 * age)
    bmr += 5 if gender.lower() == 'male' else -161

    # Map activity level keys to factors
    activity_factors = {"low": 1.2, "medium": 1.55, "high": 1.9}
    factor = activity_factors.get(activity_level_key, 1.2) # Default to low if key not found

    tdee = bmr * factor

    if goal == 'cut':
        # For cutting, a deficit of 500-750 calories is common.
        # This aims for 0.5-0.75 kg loss per week (1 kg = approx 7700 calories)
        # Let's target a 500-calorie deficit for simplicity.
        return round(tdee - 500, 2)
    elif goal == 'bulk':
        # For bulking, a surplus of 250-500 calories is common.
        return round(tdee + 300, 2) # Moderate surplus
    else: # maintenance
        return round(tdee, 2)

def calculate_protein(weight_kg, goal='maintenance'):
    factor = {"cut": 2.0, "bulk": 2.2, "maintenance": 1.6}
    return round(weight_kg * factor.get(goal, 1.6), 2)

def calculate_cardio_recommendation(activity_level_key, goal):
    # Basic recommendation based on activity and goal
    # General health recommendation: 150-300 min moderate, or 75-150 min vigorous per week
    # For cutting, more cardio is often recommended.
    if goal == 'cut':
        if activity_level_key == 'high':
            return "45-60 minutes, 4-5 times/week (vigorous)"
        elif activity_level_key == 'medium':
            return "30-45 minutes, 4-5 times/week (moderate/vigorous)"
        else: # low
            return "20-30 minutes, 3-4 times/week (moderate)"
    else: # maintenance or bulk
        if activity_level_key == 'high':
            return "30-45 minutes, 3-4 times/week (moderate)"
        elif activity_level_key == 'medium':
            return "20-30 minutes, 3-4 times/week (moderate)"
        else: # low
            return "15-20 minutes, 2-3 times/week (light/moderate)"

class GymHelperWidget:
    def __init__(self):
        # Data is loaded globally before instantiation
        self.user_profile = user_profile
        self.session_history = session_history
        self.streak_data = streak_data
        self.goals = goals
        self.pinned_plan = pinned_plan
        self.saved_plans = saved_plans
        self.gym_schedule = gym_schedule
        self.daily_workout_plans = daily_workout_plans

        self.exercise_db = exercise_db
        self.day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        self.muscle_groups = ["All"] + sorted(list(set(info["primary"] for info in self.exercise_db.values())))

        # Timer variables
        self.timer_running = False
        self.timer_thread = None # To hold the threading.Timer instance
        self.countdown_total_seconds = 0
        self.countdown_remaining_seconds = 0
        self.timer_label = widgets.Label("00:00:00")
        self.timer_output = widgets.Output()

        # Flag for progressive overload input mode in "Add Exercise" section
        self.is_progressive_overload_mode = False

        # Initialize today_plan BEFORE any init_*_tab methods that might use it
        self.today_plan = [] # Stores exercises for the current session with sets/reps/weight

        # Initialize tab widgets
        self.init_profile_tab()
        self.init_schedule_tab()
        self.init_exercises_tab()
        self.init_session_tab()
        self.init_goals_tab()
        self.init_misc()
        self.init_pr_tab()
        self.init_timer_tab()
        self.init_recommendation_tab() # New recommendation tab
        self.init_form_guide_tab() # New form guide tab

        self.update_today_plan_box() # Initial update for empty plan

        # Temporary variable to hold the exercises for the currently selected custom plan
        self.current_editing_plan_exercises = []


        self.build_ui() # This method calls display(self.tabs)

        # Initial updates for displays
        self.update_profile_display()
        self.update_schedule_graph()
        self.on_muscle_change({'new': 'All'}) # Trigger initial exercise list update for "Exercises" tab
        # For "Schedule" tab's custom plan, need to call the appropriate update for its muscle dropdown
        self.on_plan_muscle_change({'new': 'All'}) # Initialize plan exercise dropdown
        self.update_session_display()
        self.update_streak_display()
        self.show_today_plan_reminder()

        # Initial update for recommendation tab
        # Ensure that the dropdown has options before trying to set a value
        if self.recommendation_split_dropdown.options:
            self.on_split_change({'new': self.recommendation_split_dropdown.value})
        else:
            with self.recommendation_output:
                clear_output()
                print("No recommended splits available.")

        # Initial update for form guide tab
        self.on_form_muscle_change({'new': 'All'})


    def init_profile_tab(self):
        self.name_in = widgets.Text(description="Name:", value=self.user_profile.get("name", "")) # New
        self.height_in = widgets.FloatText(description="Height (cm):", value=self.user_profile.get("height_cm", 170))
        self.weight_in = widgets.FloatText(description="Weight (kg):", value=self.user_profile.get("weight_kg", 70))
        self.body_fat_in = widgets.FloatText(description="Body Fat %:", value=self.user_profile.get("body_fat_percent", 0.0)) # New
        self.age_in = widgets.IntText(description="Age:", value=self.user_profile.get("age", 25))
        self.gender_in = widgets.Dropdown(description="Gender:", options=["Male", "Female"], value=self.user_profile.get("gender", "Male"))
        self.activity_in = widgets.Dropdown(
            description="Activity Level:",
            options=[
                ("low (1-2 days/week)", "low"),
                ("medium (3-5 days/week)", "medium"),
                ("high (6-7 days/week)", "high")
            ],
            value=self.user_profile.get("activity_level", "low")
        )
        self.goal_in = widgets.Dropdown(description="Diet Goal:", options=["maintenance", "cut", "bulk"], value=self.user_profile.get("goal", "maintenance"))
        self.update_profile_btn = widgets.Button(description="Update Profile")

        self.bmi_label = widgets.Label()
        self.calorie_label = widgets.Label()
        self.protein_label = widgets.Label()
        self.cardio_rec_label = widgets.Label() # New cardio recommendation label
        self.goals_display_label = widgets.HTML() # To display current goals

        self.update_profile_btn.on_click(self.on_update_profile)

        self.profile_tab = widgets.VBox([
            widgets.Label("User Profile & Health Calculators"),
            self.name_in, # New
            self.height_in, self.weight_in, self.body_fat_in, # New body fat
            self.age_in, self.gender_in, self.activity_in, self.goal_in,
            self.update_profile_btn,
            widgets.HTML('<hr>'),
            widgets.Label("Your Metrics:"),
            self.bmi_label,
            self.calorie_label,
            self.protein_label,
            self.cardio_rec_label, # New
            widgets.HTML('<hr>'),
            widgets.Label("Your Goals:"),
            self.goals_display_label, # New
        ])

    def on_update_profile(self, _):
        self.user_profile.update({
            "name": self.name_in.value.strip(), # New
            "height_cm": self.height_in.value,
            "weight_kg": self.weight_in.value,
            "body_fat_percent": self.body_fat_in.value, # New
            "age": self.age_in.value,
            "gender": self.gender_in.value,
            "activity_level": self.activity_in.value,
            "goal": self.goal_in.value,
        })
        save_all_data()
        self.update_profile_display()
        with self.output: # Using a general output widget for messages
            clear_output()
            print("Profile updated!")

    def update_profile_display(self):
        name = self.user_profile.get("name", "N/A")
        h = self.user_profile.get("height_cm")
        w = self.user_profile.get("weight_kg")
        a = self.user_profile.get("age")
        g = self.user_profile.get("gender")
        act_level_key = self.user_profile.get("activity_level", "low") # Use the key, not the full string
        diet_goal = self.user_profile.get("goal", "maintenance")
        bf = self.user_profile.get("body_fat_percent", 0.0)

        # Update name
        if name:
            self.name_in.value = name

        if not h or not w or not a or not g:
            self.bmi_label.value = "BMI: -"
            self.calorie_label.value = "Calories: -"
            self.protein_label.value = "Protein: -"
            self.cardio_rec_label.value = "Cardio Recommendation: -"
        else:
            bmi = calculate_bmi(w, h)
            cal = calculate_calories(w, h, a, g, act_level_key, diet_goal)
            pro = calculate_protein(w, diet_goal)
            cardio_rec = calculate_cardio_recommendation(act_level_key, diet_goal)

            self.bmi_label.value = f"BMI: {bmi}"
            self.calorie_label.value = f"Calories ({diet_goal}): {cal} kcal/day (estimate)"
            self.protein_label.value = f"Protein ({diet_goal}): {pro} g/day (target)"
            self.cardio_rec_label.value = f"Cardio Recommendation: {cardio_rec}"

        # Update goals display
        weight_g = self.goals.get("weight_goal_kg", 0.0)
        muscle_g = self.goals.get("muscle_mass_goal_kg", 0.0)
        body_fat_g = self.goals.get("body_fat_goal_percent", 0.0)

        current_weight = self.user_profile.get("weight_kg", 0.0)

        goals_text = ""
        if weight_g > 0:
            weight_diff = weight_g - current_weight
            if weight_diff > 0:
                goals_text += f"• Weight Goal: {weight_g} kg ({weight_diff:.1f} kg to gain)<br>"
            elif weight_diff < 0:
                goals_text += f"• Weight Goal: {weight_g} kg ({-weight_diff:.1f} kg to lose)<br>"
            else:
                goals_text += f"• Weight Goal: {weight_g} kg (Goal reached!)<br>"

        if muscle_g > 0:
            goals_text += f"• Muscle Mass Goal: {muscle_g} kg<br>"
        if body_fat_g > 0:
            goals_text += f"• Body Fat % Goal: {body_fat_g} %<br>"

        if not goals_text:
            goals_text = "No specific goals set yet. Go to the 'Goals' tab to set them!"
        self.goals_display_label.value = goals_text


    def init_schedule_tab(self):
        # Weekly Schedule (Mon-Sun)
        self.schedule_widgets = {}
        # Ensure all possible workout types are in the dropdown options
        schedule_options = sorted(list(all_possible_workout_types))

        for day in self.day_names:
            day_dropdown = widgets.Dropdown(
                options=schedule_options, # Use expanded options
                description=day,
                value=self.gym_schedule.get(day, "Rest") if self.gym_schedule.get(day, "Rest") in schedule_options else "Rest"
            )
            day_dropdown.observe(self.on_schedule_day_change, names='value')
            self.schedule_widgets[day] = day_dropdown
        self.save_weekly_schedule_btn = widgets.Button(description="Save Weekly Schedule")
        self.save_weekly_schedule_btn.on_click(self.on_save_weekly_schedule)
        self.schedule_graph_out = widgets.Output()


        # Custom Daily Plans
        self.plan_name_input = widgets.Text(description="Plan Name:")
        self.create_plan_btn = widgets.Button(description="Create New Plan")
        self.select_plan_dropdown = widgets.Dropdown(
            options=sorted(list(self.daily_workout_plans.keys())),
            description="Select Plan:"
        )
        self.plan_muscle_dropdown = widgets.Dropdown(
            options=self.muscle_groups,
            description="Muscle Group (for adding):"
        )
        self.plan_exercise_select = widgets.Select(
            options=[],
            description="Exercises to Add:",
            rows=8
        )
        self.add_exercise_to_plan_btn = widgets.Button(description="Add to Plan")

        # This widget is now enabled for selection
        self.current_plan_exercises_display = widgets.SelectMultiple(
            options=[],
            description="Exercises in Current Plan:",
            rows=8,
            disabled=False # Set to False to allow selection for removal
        )
        self.remove_exercise_from_plan_btn = widgets.Button(description="Remove Selected from Plan")


        self.save_custom_plan_btn = widgets.Button(description="Save Selected Plan")
        self.load_custom_plan_to_today_btn = widgets.Button(description="Load Plan to Today's Plan")
        self.delete_custom_plan_btn = widgets.Button(description="Delete Selected Plan")

        self.custom_plan_output = widgets.Output() # Output for custom plan messages

        # Observers and click handlers
        self.create_plan_btn.on_click(self.on_create_custom_plan)
        self.select_plan_dropdown.observe(self.on_select_custom_plan, names='value')
        self.plan_muscle_dropdown.observe(self.on_plan_muscle_change, names='value')
        self.add_exercise_to_plan_btn.on_click(self.on_add_exercise_to_custom_plan)
        self.remove_exercise_from_plan_btn.on_click(self.on_remove_exercise_from_custom_plan)
        self.save_custom_plan_btn.on_click(self.on_save_custom_plan)
        self.load_custom_plan_to_today_btn.on_click(self.on_load_custom_plan_to_today)
        self.delete_custom_plan_btn.on_click(self.on_delete_custom_plan)


        # Initial update for custom plan dropdown and display
        self.update_custom_plan_dropdown()
        # If there are options, select the first one; otherwise, the dropdown will be empty
        if self.select_plan_dropdown.options:
            self.select_plan_dropdown.value = self.select_plan_dropdown.options[0]
        else:
            self.select_plan_dropdown.value = None # Explicitly set to None if no options
            self.current_plan_exercises_display.options = [] # Ensure display is empty

        # Ensure the 'Exercises to Add' dropdown is also updated initially
        self.on_plan_muscle_change({'new': self.plan_muscle_dropdown.value})


        self.schedule_tab = widgets.VBox([
            widgets.Label("Weekly Workout Schedule (Rest or Workout)"),
            widgets.HBox(list(self.schedule_widgets.values())),
            self.save_weekly_schedule_btn,
            self.schedule_graph_out,
            widgets.HTML('<hr>'), # Corrected: Use HTML for a horizontal rule as a separator
            widgets.Label("Create and Manage Custom Workout Plans"),
            widgets.HBox([self.plan_name_input, self.create_plan_btn]),
            self.select_plan_dropdown,
            widgets.HBox([
                widgets.VBox([ # Left side: Exercises to add
                    self.plan_muscle_dropdown,
                    self.plan_exercise_select,
                    self.add_exercise_to_plan_btn
                ], layout=widgets.Layout(width='48%')), # Adjust width for better layout
                widgets.VBox([ # Right side: Exercises in current plan
                    self.current_plan_exercises_display,
                    self.remove_exercise_from_plan_btn
                ], layout=widgets.Layout(width='48%')) # Adjust width for better layout
            ]),
            widgets.HBox([self.save_custom_plan_btn, self.load_custom_plan_to_today_btn, self.delete_custom_plan_btn]),
            self.custom_plan_output
        ])

    def on_schedule_day_change(self, change):
        day = change['owner'].description
        self.gym_schedule[day] = change['new']
        self.update_schedule_graph()
        save_all_data()
        with self.output:
            clear_output()
            print(f"Schedule for {day} set to {change['new']}.")

    def on_save_weekly_schedule(self, _):
        for day in self.day_names:
            self.gym_schedule[day] = self.schedule_widgets[day].value
        save_all_data()
        self.update_schedule_graph()
        with self.schedule_graph_out:
            clear_output()
            print("Weekly Schedule saved!")

    def update_custom_plan_dropdown(self):
        # Store current value to try and restore it if it's still valid
        current_value = self.select_plan_dropdown.value
        options = sorted(list(self.daily_workout_plans.keys()))
        self.select_plan_dropdown.options = options

        if options:
            if current_value in options:
                self.select_plan_dropdown.value = current_value
            else:
                self.select_plan_dropdown.value = options[0] # Select first if current is invalid
        else:
            self.select_plan_dropdown.value = None # Clear selection if no plans


    def on_create_custom_plan(self, _):
        plan_name = self.plan_name_input.value.strip()
        if plan_name:
            if plan_name not in self.daily_workout_plans:
                self.daily_workout_plans[plan_name] = []
                save_all_data()
                self.update_custom_plan_dropdown()
                self.select_plan_dropdown.value = plan_name # Select the newly created plan
                with self.custom_plan_output:
                    clear_output()
                    print(f"Plan '{plan_name}' created. Now add exercises.")
            else:
                with self.custom_plan_output:
                    clear_output()
                    print(f"Plan '{plan_name}' already exists. Select it from the dropdown to edit.")
        else:
            with self.custom_plan_output:
                clear_output()
                print("Please enter a name for the new plan.")

    def on_select_custom_plan(self, change):
        selected_plan_name = change['new']
        if selected_plan_name:
            self.current_editing_plan_exercises = self.daily_workout_plans.get(selected_plan_name, []).copy()
            self.current_plan_exercises_display.options = sorted(self.current_editing_plan_exercises) # Update display
            # If the selected plan is newly created and empty, `current_editing_plan_exercises` will be empty.
            with self.custom_plan_output:
                clear_output()
                print(f"Now editing plan: '{selected_plan_name}'. Add or remove exercises, then click 'Save Selected Plan'.")
        else:
            self.current_editing_plan_exercises = []
            self.current_plan_exercises_display.options = []
            with self.custom_plan_output:
                clear_output()
                print("No plan selected.")
        # Ensure the 'Exercises to Add' dropdown is also updated initially
        self.on_plan_muscle_change({'new': self.plan_muscle_dropdown.value})


    def on_plan_muscle_change(self, change):
        muscle = change['new']
        if muscle == "All":
            options = sorted(list(self.exercise_db.keys()))
        else:
            options = sorted([ex for ex, info in self.exercise_db.items() if info["primary"] == muscle.lower()])
        self.plan_exercise_select.options = options


    def on_add_exercise_to_custom_plan(self, _):
        exercise_to_add = self.plan_exercise_select.value
        selected_plan_name = self.select_plan_dropdown.value

        if not selected_plan_name:
            with self.custom_plan_output:
                clear_output()
                print("Please select or create a plan first.")
            return

        if not exercise_to_add:
            with self.custom_plan_output:
                clear_output()
                print("Please select an exercise to add.")
            return

        if exercise_to_add not in self.current_editing_plan_exercises:
            self.current_editing_plan_exercises.append(exercise_to_add)
            self.current_plan_exercises_display.options = sorted(self.current_editing_plan_exercises) # Update display
            with self.custom_plan_output:
                clear_output()
                print(f"Added '{exercise_to_add.title()}' to the current plan (not yet saved).")
        else:
            with self.custom_plan_output:
                clear_output()
                print(f"'{exercise_to_add.title()}' is already in this plan.")

    def on_remove_exercise_from_custom_plan(self, _):
        selected_exercises_to_remove = list(self.current_plan_exercises_display.value) # Now value works as it's enabled
        selected_plan_name = self.select_plan_dropdown.value

        if not selected_plan_name:
            with self.custom_plan_output:
                clear_output()
                print("Please select a plan first.")
            return

        if not selected_exercises_to_remove:
            with self.custom_plan_output:
                clear_output()
                print("Please select exercises from 'Exercises in Current Plan' to remove.")
            return

        removed_count = 0
        for ex in selected_exercises_to_remove:
            if ex in self.current_editing_plan_exercises:
                self.current_editing_plan_exercises.remove(ex)
                removed_count += 1

        self.current_plan_exercises_display.options = sorted(self.current_editing_plan_exercises) # Update display

        with self.custom_plan_output:
            clear_output()
            if removed_count > 0:
                print(f"Removed {removed_count} exercise(s) from the current plan (not yet saved).")
            else:
                print("No selected exercises were found in the plan to remove.")


    def on_save_custom_plan(self, _):
        selected_plan_name = self.select_plan_dropdown.value
        if selected_plan_name:
            self.daily_workout_plans[selected_plan_name] = sorted(self.current_editing_plan_exercises)
            save_all_data()
            with self.custom_plan_output:
                clear_output()
                print(f"Plan '{selected_plan_name}' updated and saved.")
        else:
            with self.custom_plan_output:
                clear_output()
                print("Please select a plan to save or create a new one.")

    def on_load_custom_plan_to_today(self, _):
        selected_plan_name = self.select_plan_dropdown.value
        if selected_plan_name and selected_plan_name in self.daily_workout_plans:
            plan_exercises = self.daily_workout_plans[selected_plan_name]
            # Load exercises with default sets/reps/weight (0)
            self.today_plan = []
            for ex_name in plan_exercises:
                # When loading, default to single weight mode with 0.0
                self.today_plan.append({"name": ex_name, "sets": 3, "reps": 10, "weights": 0.0, "is_progressive_overload": False}) # Added flag
            self.update_today_plan_box()
            with self.output: # Use general output
                clear_output()
                print(f"Loaded plan '{selected_plan_name}' to today's workout plan. Remember to input sets/reps/weight!")
        else:
            with self.output:
                clear_output()
                print("Please select a plan to load.")

    def on_delete_custom_plan(self, _):
        selected_plan_name = self.select_plan_dropdown.value
        if selected_plan_name and selected_plan_name in self.daily_workout_plans:
            del self.daily_workout_plans[selected_plan_name]
            save_all_data()
            self.update_custom_plan_dropdown() # Refresh dropdown
            self.current_editing_plan_exercises = [] # Clear temporary
            self.current_plan_exercises_display.options = [] # Clear display
            with self.custom_plan_output:
                clear_output()
                print(f"Plan '{selected_plan_name}' deleted.")
        else:
            with self.custom_plan_output:
                clear_output()
                print("Please select a plan to delete.")


    def update_schedule_graph(self):
        with self.schedule_graph_out:
            clear_output()
            labels = list(self.gym_schedule.keys())
            values = [1 if self.gym_schedule.get(d, "Rest")!="Rest" else 0 for d in labels] # Any value other than "Rest" is a workout
            fig, ax = plt.subplots(figsize=(6,2))
            ax.bar(labels, values, color='teal')
            ax.set_ylim(0,1.5)
            ax.set_yticks([])
            ax.set_title("Weekly Workout Schedule")
            plt.show()

    def show_today_plan_reminder(self):
        today = datetime.now().strftime("%a")
        plan = self.gym_schedule.get(today, "Rest")
        # Ensure this is displayed to the main output, not hidden in a specific tab's output
        display(widgets.HTML(f"<b>📅 Today is {today}. Your weekly schedule plan: {plan}</b>"))

    def init_exercises_tab(self):
        self.muscle_dropdown = widgets.Dropdown(
            options=self.muscle_groups,
            description="Muscle:"
        )
        self.exercise_select = widgets.Select(
            options=[],
            description="Exercises",
            rows=8
        )
        self.exercise_desc = widgets.Label(value="Select an exercise")
        self.add_exercise_btn = widgets.Button(description="Add/Update to Today's Plan")

        self.sets_input = widgets.IntText(description="Sets:", value=3)
        self.reps_input = widgets.IntText(description="Reps:", value=10)

        # This will hold either the single weight input or the VBox for multiple weights
        self.weight_input_container = widgets.VBox()
        self.single_weight_input = widgets.FloatText(description="Weight (kg):", value=0.0)
        self.progressive_overload_weights_box = widgets.VBox() # This will hold the individual weight inputs per set

        self.toggle_progressive_overload_btn = widgets.Button(description="Toggle Progressive Overload Input")
        self.toggle_progressive_overload_btn.on_click(self.on_toggle_progressive_overload)

        # Initial state: single weight input
        self.weight_input_container.children = [self.single_weight_input]

        self.today_plan_box = widgets.VBox()
        self.clear_plan_btn = widgets.Button(description="Clear Today's Plan")

        self.muscle_dropdown.observe(self.on_muscle_change, names='value')
        self.exercise_select.observe(self.on_exercise_select, names='value')
        self.add_exercise_btn.on_click(self.on_add_exercise)
        self.clear_plan_btn.on_click(self.on_clear_plan)
        # Observer for sets_input to dynamically update progressive overload weight fields
        self.sets_input.observe(self.on_sets_input_change, names='value')


        self.exercises_tab = widgets.VBox([
            widgets.Label("Browse Exercises by Muscle Group"),
            self.muscle_dropdown,
            self.exercise_select,
            self.exercise_desc,
            widgets.HBox([
                self.sets_input,
                self.reps_input,
                self.weight_input_container # This container will switch between single and multi-weight inputs
            ]),
            self.toggle_progressive_overload_btn,
            self.add_exercise_btn,
            widgets.Label("Today's Workout Plan:"),
            self.today_plan_box,
            self.clear_plan_btn,
        ])

        self.on_muscle_change({'new': 'All'}) # Trigger initial update

    def on_sets_input_change(self, change):
        if self.is_progressive_overload_mode:
            self._update_progressive_overload_inputs()

    def on_toggle_progressive_overload(self, _):
        self.is_progressive_overload_mode = not self.is_progressive_overload_mode
        with self.output:
            clear_output()
            if self.is_progressive_overload_mode:
                print("Progressive Overload mode activated. You can now set different weights for each set.")
                self._update_progressive_overload_inputs()
                self.weight_input_container.children = [self.progressive_overload_weights_box]
            else:
                print("Single Weight mode activated.")
                self.weight_input_container.children = [self.single_weight_input]
                # Reset single weight input to 0 when switching back
                self.single_weight_input.value = 0.0

    def _update_progressive_overload_inputs(self, weights_data=None):
        num_sets = self.sets_input.value
        current_weights = weights_data if weights_data is not None else []
        # If no weights_data is passed, try to get from current UI inputs
        if not weights_data and self.progressive_overload_weights_box.children:
             current_weights = [w_input.value for w_input in self.progressive_overload_weights_box.children]


        new_weight_inputs = []
        for i in range(num_sets):
            # Use existing weight if available, otherwise default to 0.0
            default_weight = current_weights[i] if i < len(current_weights) else 0.0
            weight_input = widgets.FloatText(description=f"Set {i+1} Weight:", value=default_weight)
            new_weight_inputs.append(weight_input)
        self.progressive_overload_weights_box.children = new_weight_inputs


    def on_muscle_change(self, change):
        muscle = change['new']
        if muscle == "All":
            options = sorted(list(self.exercise_db.keys()))
        else:
            options = sorted([ex for ex, info in self.exercise_db.items() if info["primary"] == muscle.lower()])
        self.exercise_select.options = options
        self.exercise_desc.value = "Select an exercise"

    def on_exercise_select(self, change):
        ex = change['new']
        if ex:
            self.exercise_desc.value = self.exercise_db.get(ex, {}).get("description", "")
        else:
            self.exercise_desc.value = "Select an exercise"

        # When selecting an exercise, try to populate inputs if it's already in today_plan
        found_ex = next((item for item in self.today_plan if item['name'] == ex), None)
        if found_ex:
            self.sets_input.value = found_ex['sets']
            self.reps_input.value = found_ex['reps']
            if found_ex.get('is_progressive_overload', False) and isinstance(found_ex['weights'], list):
                self.is_progressive_overload_mode = True
                self.weight_input_container.children = [self.progressive_overload_weights_box]
                self._update_progressive_overload_inputs(found_ex['weights']) # Pass existing weights
            else:
                self.is_progressive_overload_mode = False
                self.weight_input_container.children = [self.single_weight_input]
                # Ensure it handles if weights was a list but is_progressive_overload is False
                self.single_weight_input.value = found_ex['weights'][0] if isinstance(found_ex['weights'], list) and found_ex['weights'] else (found_ex['weights'] if isinstance(found_ex['weights'], (int, float)) else 0.0)
        else:
            # Reset inputs if new exercise selected
            self.sets_input.value = 3
            self.reps_input.value = 10
            self.is_progressive_overload_mode = False
            self.weight_input_container.children = [self.single_weight_input]
            self.single_weight_input.value = 0.0 # Reset to default for new exercise

    def on_add_exercise(self, _):
        ex_name = self.exercise_select.value
        sets = self.sets_input.value
        reps = self.reps_input.value

        if not ex_name:
            with self.output:
                clear_output()
                print("Please select an exercise to add.")
            return

        if sets <= 0 or reps <= 0:
            with self.output:
                clear_output()
                print("Sets and reps must be positive.")
            return

        weights = 0.0 # Default single weight
        is_po = self.is_progressive_overload_mode

        if is_po:
            weights_list = [w_input.value for w_input in self.progressive_overload_weights_box.children]
            if len(weights_list) != sets:
                 with self.output:
                    clear_output()
                    print(f"Mismatch: Number of weight inputs ({len(weights_list)}) does not match sets ({sets}). Please re-enter weights.")
                    return
            if any(w < 0 for w in weights_list):
                 with self.output:
                    clear_output()
                    print("All progressive overload weights must be non-negative.")
                    return
            weights = weights_list # Store as list
        else:
            weights = self.single_weight_input.value
            if weights < 0:
                with self.output:
                    clear_output()
                    print("Weight must be non-negative.")
                return

        exercise_entry = {"name": ex_name, "sets": sets, "reps": reps, "weights": weights, "is_progressive_overload": is_po}

        # Check if exercise already exists in today_plan, if so, update it. Otherwise, append.
        found = False
        for i, item in enumerate(self.today_plan):
            if item['name'] == ex_name:
                self.today_plan[i] = exercise_entry
                found = True
                break
        if not found:
            self.today_plan.append(exercise_entry)

        self.update_today_plan_box()
        with self.output:
            clear_output()
            if found:
                print(f"Updated {ex_name} in today's plan.")
            else:
                print(f"Added {ex_name} to today's plan.")


    def update_today_plan_box(self):
        children = []
        for i, ex_entry in enumerate(self.today_plan):
            ex_name = ex_entry['name']
            current_is_po = ex_entry.get('is_progressive_overload', False)

            # Create widgets for sets, reps, and weights for each exercise
            sets_widget = widgets.IntText(value=ex_entry['sets'], description="Sets:", layout=widgets.Layout(width='auto', flex='1 1 0%'))
            reps_widget = widgets.IntText(value=ex_entry['reps'], description="Reps:", layout=widgets.Layout(width='auto', flex='1 1 0%'))

            # Container for weights specific to this exercise in the display
            exercise_weights_container = widgets.VBox()
            single_weight_input_display = widgets.FloatText(
                value=ex_entry['weights'] if not isinstance(ex_entry['weights'], list) else (ex_entry['weights'][0] if ex_entry['weights'] else 0.0),
                description="Weight (kg):",
                layout=widgets.Layout(width='auto', flex='1 1 0%')
            )
            # Create a VBox to hold progressive overload weight inputs for this specific exercise in the display
            progressive_overload_display_box = widgets.VBox()

            def _update_this_exercise_po_inputs(index_to_update, num_sets, current_weights_list=None):
                new_po_inputs = []
                for j in range(num_sets):
                    default_weight = current_weights_list[j] if current_weights_list and j < len(current_weights_list) else 0.0
                    weight_input_j = widgets.FloatText(
                        value=default_weight,
                        description=f"S{j+1} Wt:",
                        layout=widgets.Layout(width='auto', flex='1 1 0%')
                    )
                    # Use a partial function or a default argument to capture `idx` and `set_idx`
                    weight_input_j.observe(lambda change, idx=index_to_update, set_idx=j: self._update_plan_exercise_detail(idx, 'weights', change['new'], set_idx=set_idx), names='value')
                    new_po_inputs.append(weight_input_j)
                progressive_overload_display_box.children = new_po_inputs

            def _toggle_exercise_po(btn_obj, index_of_ex_in_plan=i):
                ex = self.today_plan[index_of_ex_in_plan]
                current_status = ex.get('is_progressive_overload', False)
                ex['is_progressive_overload'] = not current_status

                # Update weights data structure
                if ex['is_progressive_overload']:
                    # Convert single weight to list of weights, or initialize if no weights
                    if not isinstance(ex['weights'], list):
                        single_weight_val = ex['weights'] if isinstance(ex['weights'], (int, float)) else 0.0
                        ex['weights'] = [single_weight_val] * ex['sets']
                else:
                    # Convert list of weights to single weight (take first or 0.0)
                    if isinstance(ex['weights'], list) and ex['weights']:
                        ex['weights'] = ex['weights'][0]
                    else:
                        ex['weights'] = 0.0 # Default if list was empty or invalid

                # Re-render the entire today_plan_box to reflect changes for this exercise
                self.update_today_plan_box()
                with self.output:
                    clear_output()
                    print(f"Toggled progressive overload for {ex['name'].title()}.")


            # Set initial display for weights
            if current_is_po and isinstance(ex_entry['weights'], list):
                _update_this_exercise_po_inputs(i, ex_entry['sets'], ex_entry['weights'])
                exercise_weights_container.children = [progressive_overload_display_box]
            else:
                exercise_weights_container.children = [single_weight_input_display]

            # Observe changes for sets and reps for this specific exercise
            sets_widget.observe(lambda change, idx=i: self._update_plan_exercise_detail(idx, 'sets', change['new'], progressive_overload_updater=_update_this_exercise_po_inputs), names='value')
            reps_widget.observe(lambda change, idx=i: self._update_plan_exercise_detail(idx, 'reps', change['new']), names='value')
            # Observe changes for single weight input for this specific exercise
            single_weight_input_display.observe(lambda change, idx=i: self._update_plan_exercise_detail(idx, 'weights', change['new']), names='value')

            remove_btn = widgets.Button(description="X", layout=widgets.Layout(width='30px'))
            remove_btn.on_click(lambda btn, idx=i: self.remove_from_plan(idx))

            # New: Progressive Overload Toggle Button for each displayed exercise
            toggle_po_btn_per_exercise = widgets.Button(
                description="Toggle PO",
                layout=widgets.Layout(width='auto', flex='1 1 0%')
            )
            toggle_po_btn_per_exercise.on_click(lambda btn, idx=i: _toggle_exercise_po(btn, idx))


            # Assemble the HBox for each exercise
            children.append(widgets.VBox([
                widgets.Label(f"<b>{ex_name.title()}</b>", layout=widgets.Layout(width='auto')), # Exercise name
                widgets.HBox([sets_widget, reps_widget] + list(exercise_weights_container.children) + [toggle_po_btn_per_exercise, remove_btn], layout=widgets.Layout(display='flex', flex_flow='row wrap', align_items='center'))
            ], layout=widgets.Layout(border='1px solid lightgray', padding='5px', margin='2px 0'))) # Add borders for clarity

        self.today_plan_box.children = children

    def _update_plan_exercise_detail(self, index, key, new_value, set_index=None, progressive_overload_updater=None):
        if 0 <= index < len(self.today_plan):
            ex_entry = self.today_plan[index]
            if key == 'weights':
                if isinstance(ex_entry['weights'], list):
                    # Update specific weight in list for progressive overload
                    if set_index is not None and 0 <= set_index < len(ex_entry['weights']):
                        ex_entry['weights'][set_index] = new_value
                else:
                    # Update single weight
                    ex_entry['weights'] = new_value
            elif key == 'sets':
                ex_entry[key] = new_value
                if ex_entry.get('is_progressive_overload', False):
                    current_weights = ex_entry['weights'] if isinstance(ex_entry['weights'], list) else []
                    new_num_sets = new_value
                    if new_num_sets > len(current_weights):
                        ex_entry['weights'].extend([0.0] * (new_num_sets - len(current_weights)))
                    elif new_num_sets < len(current_weights):
                        ex_entry['weights'] = current_weights[:new_num_sets]
                    # Since sets changed in PO mode, re-render the specific inputs for that exercise
                    self.update_today_plan_box() # Rebuilds the whole box
            else:
                ex_entry[key] = new_value

            # Optional: provide feedback to user in output
            # with self.output:
            #     clear_output()
            #     print(f"Updated {self.today_plan[index]['name']} - {key}: {new_value}")

    def remove_from_plan(self, index):
        if 0 <= index < len(self.today_plan):
            removed_ex = self.today_plan.pop(index)
            self.update_today_plan_box()
            with self.output:
                clear_output()
                print(f"Removed {removed_ex['name']} from today's plan.")

    def on_clear_plan(self, _):
        self.today_plan = []
        self.update_today_plan_box()
        with self.output:
            clear_output()
            print("Today's plan cleared.")


    def init_session_tab(self):
        self.session_out = widgets.Output()
        self.log_session_btn = widgets.Button(description="Log Today's Workout")
        self.view_history_btn = widgets.Button(description="View Session History")
        self.clear_history_btn = widgets.Button(description="Clear Session History")

        self.log_session_btn.on_click(self.on_log_session)
        self.view_history_btn.on_click(self.on_view_history)
        self.clear_history_btn.on_click(self.on_clear_history)

        self.session_tab = widgets.VBox([
            widgets.Label("Workout Sessions & History"),
            self.log_session_btn,
            self.view_history_btn,
            self.clear_history_btn,
            self.session_out
        ])

    def on_log_session(self, _):
        if not self.today_plan:
            with self.session_out:
                clear_output()
                print("No exercises in today's plan to log!")
            return

        # Validate that all exercises in today_plan have sets/reps/weight(s)
        for ex in self.today_plan:
            if ex['sets'] <= 0 or ex['reps'] <= 0:
                with self.session_out:
                    clear_output()
                    print(f"Please enter valid sets and reps for {ex['name'].title()} before logging.")
                return
            if isinstance(ex['weights'], list):
                if not ex['weights'] or any(w < 0 for w in ex['weights']):
                     with self.session_out:
                        clear_output()
                        print(f"Please enter valid (non-negative) weights for all sets of {ex['name'].title()} before logging.")
                        return
            elif ex['weights'] < 0:
                with self.session_out:
                    clear_output()
                    print(f"Please enter valid (non-negative) weight for {ex['name'].title()} before logging.")
                return


        session = {
            "date": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "exercises": self.today_plan.copy() # Now copies list of dicts
        }
        self.session_history.append(session)
        save_all_data()

        # Update streaks - need to pass the date string
        self.update_streak(session["date"].split(" ")[0])


        with self.session_out:
            clear_output()
            exercises_logged = []
            for ex in self.today_plan:
                weight_info = ""
                if isinstance(ex['weights'], list):
                    weight_info = f"@{', '.join(map(str, ex['weights']))}kg (per set)"
                else:
                    weight_info = f"@{ex['weights']}kg"
                exercises_logged.append(f"{ex['name']} ({ex['sets']}x{ex['reps']} {weight_info})")
            print(f"Logged session with exercises: {', '.join(exercises_logged)}")
        self.today_plan.clear() # Clear the current plan after logging
        self.update_today_plan_box() # Update the displayed plan box
        self.update_streak_display() # Update streak display after logging


    def on_view_history(self, _):
        with self.session_out:
            clear_output()
            if not self.session_history:
                print("No session history.")
                return
            print("--- Recent Session History ---")
            # Sort history by date, newest first for better readability
            sorted_history = sorted(self.session_history, key=lambda x: datetime.strptime(x['date'], "%Y-%m-%d %H:%M"), reverse=True)
            for session in sorted_history[:10]: # Show last 10 sessions
                print(f"Date: {session['date']}")
                for ex in session['exercises']:
                    # Ensure handling if 'sets', 'reps', 'weights' keys are missing (for older entries)
                    sets = ex.get('sets', 'N/A')
                    reps = ex.get('reps', 'N/A')
                    weights_val = ex.get('weights', 'N/A') # Use 'weights' key now

                    weight_info = ""
                    if isinstance(weights_val, list):
                        weight_info = f"@{', '.join(map(str, weights_val))} kg (per set)"
                    else:
                        weight_info = f"@{weights_val} kg"

                    print(f"  - {ex['name'].title()}: {sets} sets of {reps} reps {weight_info}")
                print("-" * 30)


    def on_clear_history(self, _):
        self.session_history.clear()
        save_all_data()
        with self.session_out:
            clear_output()
            print("Session history cleared.")

    def update_session_display(self):
        pass


    def init_goals_tab(self):
        self.workout_goal_in = widgets.IntText(description="Workouts/week:", value=self.goals.get("workouts", 5))
        self.volume_goal_in = widgets.IntText(description="Volume (sets):", value=self.goals.get("volume", 10000))
        self.streak_goal_in = widgets.IntText(description="Streak Goal (days):", value=self.goals.get("streak_goal", 7))
        # New goal inputs
        self.weight_goal_in = widgets.FloatText(description="Weight Goal (kg):", value=self.goals.get("weight_goal_kg", 0.0))
        self.muscle_mass_goal_in = widgets.FloatText(description="Muscle Mass Goal (kg):", value=self.goals.get("muscle_mass_goal_kg", 0.0))
        self.body_fat_goal_in = widgets.FloatText(description="Body Fat % Goal:", value=self.goals.get("body_fat_goal_percent", 0.0))

        self.save_goals_btn = widgets.Button(description="Save Goals")
        self.goals_out = widgets.Output()
        self.save_goals_btn.on_click(self.on_save_goals)

        self.streak_label = widgets.Label()
        # update_streak_display is called in __init__ after loading data


        self.goals_tab = widgets.VBox([
            widgets.Label("Set Your Workout Goals"),
            self.workout_goal_in,
            self.volume_goal_in,
            self.streak_goal_in,
            widgets.HTML('<hr>'),
            widgets.Label("Specific Body Composition Goals: (Enter 0 to unset)"),
            self.weight_goal_in,
            self.muscle_mass_goal_in,
            self.body_fat_goal_in,
            self.save_goals_btn,
            self.goals_out,
            widgets.Label("Current Workout Streak:"),
            self.streak_label,
        ])

    def on_save_goals(self, _):
        self.goals["workouts"] = self.workout_goal_in.value
        self.goals["volume"] = self.volume_goal_in.value
        self.goals["streak_goal"] = self.streak_goal_in.value
        self.goals["weight_goal_kg"] = self.weight_goal_in.value
        self.goals["muscle_mass_goal_kg"] = self.muscle_mass_goal_in.value
        self.goals["body_fat_goal_percent"] = self.body_fat_goal_in.value
        save_all_data()
        self.update_profile_display() # Update profile to show new goals
        with self.goals_out:
            clear_output()
            print("Goals saved!")
        self.update_streak_display() # Update streak display if streak goal changed


    def update_streak(self, session_date_str):
        today = datetime.now().date()
        last_date_str = self.streak_data.get("last_date")

        if last_date_str:
            last_date = datetime.strptime(last_date_str, "%Y-%m-%d").date()
            delta = (today - last_date).days

            if delta == 0: # Logged multiple times today
                pass # Streak doesn't change
            elif delta == 1: # Logged yesterday
                self.streak_data["current_streak"] += 1
            else: # Gap in logging
                self.streak_data["current_streak"] = 1
        else: # First log
            self.streak_data["current_streak"] = 1

        self.streak_data["last_date"] = today.strftime("%Y-%m-%d")
        if self.streak_data["current_streak"] > self.streak_data.get("longest_streak", 0):
            self.streak_data["longest_streak"] = self.streak_data["current_streak"]
        save_all_data()


    def update_streak_display(self):
        cs = self.streak_data.get("current_streak", 0)
        ls = self.streak_data.get("longest_streak", 0)
        goal = self.goals.get("streak_goal", 7)
        self.streak_label.value = f"Current Streak: {cs} days (Longest: {ls} days)"
        if cs >= goal and goal > 0:
            self.streak_label.value += f" 🎉 Goal reached! ({cs} ≥ {goal})"
        elif goal > 0:
            self.streak_label.value += f" | Goal: {goal} days. Keep going!"
        # No message if goal is 0 or less


    def init_misc(self):
        self.output = widgets.Output()
        self.misc_tab = widgets.VBox([
            widgets.Label("Miscellaneous Output & Debug"),
            self.output
        ])

    def init_pr_tab(self):
        self.pr_records = {}
        try:
            with open(f"{save_path}/pr_records.json", "r") as f:
                self.pr_records = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            with self.output:
                clear_output()
                print("ℹ️ No PR data found or error decoding PR data, starting fresh for PRs.")
            self.pr_records = {}


        self.pr_input = widgets.Text(description="Exercise")
        self.pr_value = widgets.FloatText(description="Max Weight")
        self.pr_btn = widgets.Button(description="Save PR")
        self.pr_output = widgets.Output()

        self.pr_btn.on_click(self.save_pr)

        self.pr_tab = widgets.VBox([
            widgets.Label("Personal Records (PRs)"),
            self.pr_input,
            self.pr_value,
            self.pr_btn,
            self.pr_output
        ])
        self.display_pr_records() # Display PRs on load


    def save_pr(self, _):
        ex = self.pr_input.value.strip().lower()
        wt = self.pr_value.value
        if ex and wt > 0:
            self.pr_records[ex] = wt
            try:
                with open(f"{save_path}/pr_records.json", "w") as f:
                    json.dump(self.pr_records, f)
            except Exception as e:
                    with self.pr_output:
                        clear_output()
                        print(f"⚠️ Error saving PR data: {e}")

            self.display_pr_records()
            with self.output: # Use general output
                    clear_output()
                    print(f"Saved PR for {ex.title()}: {wt} kg")
        else:
            with self.pr_output:
                clear_output()
                print("Please enter a valid exercise and weight.")


    def display_pr_records(self):
        with self.pr_output:
            clear_output()
            if not self.pr_records:
                print("No PRs saved yet.")
                return
            print("Your Personal Records:")
            for k, v in sorted(self.pr_records.items()):
                print(f"- {k.title()}: {v} kg")

    def init_timer_tab(self):
        self.timer_hours_input = widgets.IntText(description="Hours:", value=0, min=0, max=23)
        self.timer_minutes_input = widgets.IntText(description="Minutes:", value=0, min=0, max=59)
        self.timer_seconds_input = widgets.IntText(description="Seconds:", value=0, min=0, max=59)

        self.set_timer_btn = widgets.Button(description="Set Timer")
        self.start_timer_btn = widgets.Button(description="Start Timer")
        self.pause_timer_btn = widgets.Button(description="Pause Timer")
        self.reset_timer_btn = widgets.Button(description="Reset Timer")

        self.set_timer_btn.on_click(self.on_set_timer)
        self.start_timer_btn.on_click(self.on_start_timer)
        self.pause_timer_btn.on_click(self.on_pause_timer)
        self.reset_timer_btn.on_click(self.on_reset_timer)

        # Initial display for the timer
        self.timer_label.value = "00:00:00"

        self.timer_tab = widgets.VBox([
            widgets.Label("Workout Countdown Timer"),
            widgets.HBox([self.timer_hours_input, self.timer_minutes_input, self.timer_seconds_input]),
            self.set_timer_btn,
            self.timer_label,
            widgets.HBox([self.start_timer_btn, self.pause_timer_btn, self.reset_timer_btn]),
            self.timer_output
        ])

    def on_set_timer(self, _):
        hours = self.timer_hours_input.value
        minutes = self.timer_minutes_input.value
        seconds = self.timer_seconds_input.value

        if not (0 <= hours <= 23 and 0 <= minutes <= 59 and 0 <= seconds <= 59):
            with self.timer_output:
                clear_output()
                print("Please enter valid time (HH:MM:SS).")
            return

        self.countdown_total_seconds = (hours * 3600) + (minutes * 60) + seconds
        self.countdown_remaining_seconds = self.countdown_total_seconds
        self.timer_label.value = self._format_time(self.countdown_remaining_seconds)
        self.timer_running = False # Ensure it's not running when setting
        self._cancel_timer_thread() # Cancel any existing timer
        with self.timer_output:
            clear_output()
            print(f"Timer set to {self._format_time(self.countdown_total_seconds)}")
            if self.countdown_total_seconds == 0:
                print("Timer set to 0. It won't count down until a duration is set.")


    def on_start_timer(self, _):
        if not self.timer_running and self.countdown_remaining_seconds > 0:
            self.timer_running = True
            self._schedule_next_timer_update() # Start the recursive scheduling
            with self.timer_output:
                clear_output()
                print("Timer started!")
        elif self.countdown_remaining_seconds == 0:
            with self.timer_output:
                clear_output()
                print("Timer duration is 0. Please set a duration first.")
        else:
            with self.timer_output:
                clear_output()
                print("Timer is already running.")


    def on_pause_timer(self, _):
        if self.timer_running:
            self.timer_running = False
            self._cancel_timer_thread()
            with self.timer_output:
                clear_output()
                print("Timer paused.")

    def on_reset_timer(self, _):
        self.timer_running = False
        self.countdown_total_seconds = 0
        self.countdown_remaining_seconds = 0
        self.timer_label.value = "00:00:00"
        self._cancel_timer_thread()
        with self.timer_output:
            clear_output()
            print("Timer reset.")

    def _schedule_next_timer_update(self):
        if not self.timer_running or self.countdown_remaining_seconds <= 0:
            self.timer_running = False # Ensure flag is false if time runs out
            self.countdown_remaining_seconds = 0 # Ensure it's exactly 0
            self.timer_label.value = "00:00:00"
            if "TIME'S UP!" not in self.timer_output.value: # Avoid reprinting if already there
                with self.timer_output:
                    clear_output()
                    print("TIME'S UP!")
            return

        # Decrement by 1 second for each scheduled call
        self.countdown_remaining_seconds -= 1
        self.timer_label.value = self._format_time(self.countdown_remaining_seconds)

        # Schedule the next update
        if self.timer_running and self.countdown_remaining_seconds > 0:
            self.timer_thread = threading.Timer(1.0, self._schedule_next_timer_update)
            self.timer_thread.daemon = True # Allow app to exit even if timer is running
            self.timer_thread.start()
        else: # Time has run out after decrementing
            self.timer_running = False
            self.countdown_remaining_seconds = 0
            self.timer_label.value = "00:00:00"
            with self.timer_output:
                clear_output()
                print("TIME'S UP!")


    def _cancel_timer_thread(self):
        if self.timer_thread and self.timer_thread.is_alive():
            self.timer_thread.cancel()
            self.timer_thread = None


    def _format_time(self, seconds):
        hours, remainder = divmod(int(seconds), 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours:02}:{minutes:02}:{seconds:02}"

    # === New Recommendation Tab ===
    def init_recommendation_tab(self):
        self.recommendation_split_dropdown = widgets.Dropdown(
            options=sorted(list(recommended_splits.keys())),
            description="Select Split:"
        )
        self.recommendation_schedule_out = widgets.Output()
        self.recommended_exercises_out = widgets.Output()
        self.use_recommended_plan_btn = widgets.Button(description="Use This Recommended Plan")
        self.recommendation_output = widgets.Output()

        self.recommendation_split_dropdown.observe(self.on_split_change, names='value')
        self.use_recommended_plan_btn.on_click(self.on_use_recommended_plan)

        self.recommendation_tab = widgets.VBox([
            widgets.Label("Workout Plan Recommendations"),
            self.recommendation_split_dropdown,
            widgets.HTML('<hr>'),
            widgets.Label("Recommended Weekly Schedule:"),
            self.recommendation_schedule_out,
            widgets.HTML('<hr>'),
            widgets.Label("Recommended Exercises per Day:"),
            self.recommended_exercises_out,
            widgets.HTML('<hr>'),
            self.use_recommended_plan_btn,
            self.recommendation_output
        ])

    def on_split_change(self, change):
        selected_split = change['new']
        with self.recommendation_schedule_out:
            clear_output()
            if selected_split and selected_split in recommended_splits:
                schedule = recommended_splits[selected_split]["schedule"]
                schedule_text = ""
                for day in self.day_names:
                    activity = schedule.get(day, "Rest")
                    schedule_text += f"<b>{day}:</b> {activity}<br>"
                display(widgets.HTML(schedule_text))
            else:
                print("No schedule available for this split or no split selected.")

        with self.recommended_exercises_out:
            clear_output()
            if selected_split and selected_split in recommended_splits:
                plans = recommended_splits[selected_split]["plans"]
                exercises_text = ""
                for plan_name, exercises in plans.items():
                    exercises_text += f"<b>{plan_name} Workout:</b><br>"
                    for ex in exercises:
                        exercises_text += f"  - {ex.title()}<br>"
                    exercises_text += "<br>" # Add a line break between plans
                display(widgets.HTML(exercises_text))
            else:
                print("No exercises available for this split or no split selected.")


    def on_use_recommended_plan(self, _):
        selected_split = self.recommendation_split_dropdown.value
        if not selected_split or selected_split not in recommended_splits:
            with self.recommendation_output:
                clear_output()
                print("Please select a recommended plan first.")
            return

        split_data = recommended_splits[selected_split]

        # Overwrite gym_schedule
        self.gym_schedule.clear()
        for day, activity in split_data["schedule"].items():
            self.gym_schedule[day] = activity

        # Overwrite daily_workout_plans
        # Clear existing daily plans first to ensure a clean overwrite
        self.daily_workout_plans.clear()
        for plan_name, exercises in split_data["plans"].items():
            self.daily_workout_plans[plan_name] = exercises

        save_all_data()

        # Update relevant UI elements
        # Dynamically update the options for schedule_widgets based on the new schedule's activities
        # This is crucial to avoid TraitErrors if new workout names are introduced.
        updated_schedule_options = sorted(list(all_possible_workout_types.union(self.gym_schedule.values())))
        for day in self.day_names:
            # First, update the options for each dropdown
            self.schedule_widgets[day].options = updated_schedule_options
            # Then, set the value (it should now be valid)
            self.schedule_widgets[day].value = self.gym_schedule.get(day, "Rest")

        self.update_schedule_graph() # Refresh schedule graph
        self.update_custom_plan_dropdown() # Refresh custom plan dropdown

        with self.recommendation_output:
            clear_output()
            print(f"Successfully applied '{selected_split}' plan to your schedule and custom daily workout plans!")
        with self.output: # General output for important messages
            clear_output()
            print(f"Your weekly schedule and daily workout plans have been updated with '{selected_split}'.")

    # === New: Exercises Form Guide Tab ===
    def init_form_guide_tab(self):
        self.form_muscle_dropdown = widgets.Dropdown(
            options=self.muscle_groups,
            description="Muscle Group:"
        )
        self.form_exercise_dropdown = widgets.Dropdown(
            options=[],
            description="Exercise:"
        )
        self.search_form_btn = widgets.Button(description="Search Form Guide")
        self.form_guide_output = widgets.Output()

        self.form_muscle_dropdown.observe(self.on_form_muscle_change, names='value')
        self.search_form_btn.on_click(self.on_search_form_guide)

        self.form_guide_tab = widgets.VBox([
            widgets.Label("Exercises Form Guide"),
            self.form_muscle_dropdown,
            self.form_exercise_dropdown,
            self.search_form_btn,
            self.form_guide_output
        ])

    def on_form_muscle_change(self, change):
        muscle = change['new']
        if muscle == "All":
            options = sorted(list(self.exercise_db.keys()))
        else:
            options = sorted([ex for ex, info in self.exercise_db.items() if info["primary"] == muscle.lower()])
        self.form_exercise_dropdown.options = options
        if options:
            self.form_exercise_dropdown.value = options[0] # Select first exercise by default
        else:
            self.form_exercise_dropdown.value = None

    def on_search_form_guide(self, _):
        selected_exercise = self.form_exercise_dropdown.value
        if not selected_exercise:
            with self.form_guide_output:
                clear_output()
                print("Please select an exercise to search for a form guide.")
            return

        with self.form_guide_output:
            clear_output()
            print(f"Searching for '{selected_exercise.title()} form guide' on YouTube...")

            # Use the Google Search tool to find YouTube links
            query = f"proper {selected_exercise} form youtube"
            try:

                processed_results = search_results[0]['results']

                youtube_links = []
                for result in processed_results:
                    if "youtube.com/watch" in result.get('link', ''):
                        youtube_links.append(result['link'])
                    if len(youtube_links) >= 3: # Get up to 3 links
                        break

                if youtube_links:
                    print(f"Found form guides for {selected_exercise.title()}:")
                    for i, link in enumerate(youtube_links):
                        print(f"{i+1}. {link}")
                else:
                    print(f"No relevant YouTube form guides found for {selected_exercise.title()}.")

            except Exception as e:
                print(f"An error occurred during search: {e}")


    def build_ui(self):
        self.tabs = widgets.Tab(children=[
            self.profile_tab,
            self.schedule_tab,
            self.exercises_tab,
            self.session_tab,
            self.goals_tab,
            self.misc_tab,
            self.pr_tab,
            self.timer_tab,
            self.recommendation_tab,
            self.form_guide_tab # Add the new tab
        ])
        tab_names = ["Profile", "Schedule", "Exercises", "Session", "Goals", "Misc", "PR", "Timer", "Recommend", "Form Guide"]
        for i, name in enumerate(tab_names):
            self.tabs.set_title(i, name)

        # The key to displaying the widget in Colab/Jupyter is calling display() on the top-level widget.
        display(self.tabs)

# === Launch App ===
# Create an instance of the widget class.
# The build_ui method within __init__ will then call display(self.tabs).
gym_app = GymHelperWidget()